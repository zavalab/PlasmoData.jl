var documenterSearchIndex = {"docs":
[{"location":"guide/#Getting-Started","page":"Quick Start","title":"Getting Started","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"A DataGraph can be initiated by calling ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"dg = DataGraph()","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"PlasmoData.jl also supports building a DataGraph from an adjacency matrix. The DataGraph can be changed by adding nodes or edges to the graph, as shown below. add_node! takes two arguments: the DataGraph of interest and the node name (any data type is permitted). add_edge takes three arguments, the DataGraph of interest, and the names of two nodes in the graph. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"add_node!(dg, \"node1\")\nadd_node!(dg, :node2)\nadd_node!(dg, 3)\n\nadd_edge!(dg, \"node1\", :node2)\nadd_edge!(dg, 3, :node2)\nadd_edge!(dg, \"node1\", 3)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Data can be added to these nodes or edges by calling add_node_data! or add_edge_data! as shown below. Here, these functions take similar arguments to add_node! or add_edge!, but they also take two additional arguments, one for the weight value and one for the attribute name (must be a string). When setting a new attribute, the other nodes or edges will receive a default value of 0. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"add_node_data!(dg, \"node1\", 1.0,   \"node_weight_1\")\nadd_node_data!(dg, :node2,  2.0, \"node_weight_1\")\nadd_node_data!(dg, 3,       3.0,   \"node_weight_1\")\n\nadd_edge_data!(dg, \"node1\", :node2,  4.0, \"edge_weight_1\")\nadd_edge_data!(dg, :node2,  3,       5.0, \"edge_weight_1\")\nadd_edge_data!(dg, 3,       \"node1\", 6.0, \"edge_weight_1\")","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Note that for DataGraphs, the order of the nodes in the edge is not important, but it is important for DataDiGraphs. ","category":"page"},{"location":"guide/#Additional-Functions-for-Building-Graphs","page":"Quick Start","title":"Additional Functions for Building Graphs","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"There are also functions for direclty building a graph from a set of data. Examples are shown below.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"random_matrix = rand(20, 20)\n\nmatrix_graph = matrix_to_graph(random_matrix, \"matrix_weight\")\n\nsymmetric_random_matrix = random_matrix .+ random_matrix'\n\nsymmetric_matrix_graph = symmetric_matrix_to_graph(symmetric_random_matrix, \"matrix_weight\")\n\nrandom_tensor = rand(20, 20, 15)\n\ntensor_graph = tensor_to_graph(random_tensor)\n\nmatrix_graph_multiple_weights = matrix_to_graph(random_tensor)","category":"page"},{"location":"guide/#Manipulating-Graph-Structure","page":"Quick Start","title":"Manipulating Graph Structure","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"PlasmoData.jl enables manipulating graph structure while maintaining the data in the resulting graph. For both DataGraphs and DataDiGraphs, users can call filter_nodes, filter_edges, aggregate, remove_node!, and remove_edge!. ","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"# Keep nodes for which the \"matrix_weight\" is greater than 0.5\nfiltered_graph = filter_nodes(matrix_graph, 0.5, \"matrix_weight\", fn = Base.isgreater)\n\n# Keep edges for which the \"matrix_weight\" is less than 0.5\nfiltered_graph = filter_edges(symmetric_matrix_graph, 0.5, \"matrix_weight\", fn = Base.isless)\n\n# aggregate the nodes (2, 3), (2, 4), and (3, 3) together\naggregated_graph = aggregate(matrix_graph, [(2, 3), (2, 4), (3, 3)], \"new_node\")\n\nremove_node!(matrix_graph, (4, 4))\nremove_edge!(matrix_graph, (4, 5), (4, 6))","category":"page"},{"location":"guide/#Data-Analysis","page":"Quick Start","title":"Data Analysis","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Representing and modeling data as a graph enables unique analysis, including analyzing the topology of the resulting graph. Topological Data Analysis (TDA) can be applied generally to geometric shapes, including to graphs. TDA is an expanding field, and it has been shown to be a powerful data analysis tool for many systems. Some TDA is enabled within PlasmoData.jl (in many cases, through extending the functions of Graphs.jl).","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"The Euler Characteristic (EC) is a topological descriptor for geometric objects. For graphs, the EC is equal to the number of nodes minus the number of edges (or equivalently, the number of connected components minus the number of cycles). Often, the EC is combined with filtration to form an EC Curve. For node- or edge-weighted graphs, this involves filtering out nodes or edges of a graph based on their weight value and computing the EC of the resulting structure. This is done at a range of threshold values to get a vector (curve). PlasmoData.jl provides functions for computing the EC and the EC curve (note that the EC only applies to DataGraphs and not DataDiGraphs)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"thresh = 0:.01:1\n\nEC_curve = run_EC_on_nodes(matrix_graph, thresh)\n\nEC_curve = run_EC_on_edges(symmetric_matrix_graph, thresh)\n\nEC = get_EC(matrix_graph)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"Other metrics are also available for studying the topology of the graph. Some examples are shown below (largely extensions of Graphs.jl)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"ad = average_degree(matrix_graph)\n\ncycles = Graphs.cycle_basis(matrix_graph)\n\nconn_comp = Graphs.connected_components(matrix_graph)\n\nneighbor_list = Graphs.neighbors(matrix_graph, (2, 2))\n\ndiam = Graphs.diameter(matrix_graph)\n\ncommunities = Graphs.clique_percolation(matrix_graph, k = 3)\n\nmax_clique = Graphs.maximal_cliques(matrix_graph)","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"In addition, there are also functions for analyzing the connections in directed graphs. These include has_path (returns true or false depending on if there is a path between two given nodes) and get_path (returns the path between two given nodes if it exists). In addition, these functions can also take another argument of an intermediate node (i.e., for detecting a path between two nodes that passes through the intermediate node).  In addition, there are functions to get all the upstream and downstream nodes of a given node using upstream_nodes and downstream_nodes.","category":"page"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"nodes = [1, 2, 3, 4, 5]\nedges = [(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 4)]\n\ndg = DataDiGraph()\nfor i in nodes\n    add_node!(dg, i)\nend\n\nfor i in edges\n    add_edge!(dg, i)\nend\n\n# Test if there is a path between nodes 1 and 4\nPlasmoData.has_path(dg, 1, 4)\n\n# Test if there is a path between nodes 1 and 5 that passes through 4\nPlasmoData.has_path(dg, 1, 4, 5)\n\n# Return the (shortest) path between Nodes 1 and 4\nget_path(dg, 1, 4)\n\n# Return the (shortest) path between Nodes 1 and 4 that passes through 2\nget_path(dg, 1, 2, 4)\n\nup_nodes = upstream_nodes(dg, 4)\n\ndown_nodes = downstream_nodes(dg, 1","category":"page"},{"location":"guide/#Further-Examples","page":"Quick Start","title":"Further Examples","text":"","category":"section"},{"location":"guide/","page":"Quick Start","title":"Quick Start","text":"To see additional examples of how PlasmoData.jl can be used, please see the examples directory within this repository.","category":"page"},{"location":"api/#API-Manual","page":"API Manual","title":"API Manual","text":"","category":"section"},{"location":"api/","page":"API Manual","title":"API Manual","text":"Modules = [PlasmoData]","category":"page"},{"location":"api/#PlasmoData.DataGraphUnion","page":"API Manual","title":"PlasmoData.DataGraphUnion","text":"DataGraphUnion\n\nData type that is a union of DataGraph and DataDiGraph; used for functions that apply to both data types\n\n\n\n\n\n","category":"type"},{"location":"api/#PlasmoData.DataDiGraph","page":"API Manual","title":"PlasmoData.DataDiGraph","text":"DataDiGraph{T, T1, T2, T3, M1, M2}\n\nObject for building and storing directed graphs that contain numerical data on nodes and/or edges.\n\nDataDiGraphs have the following attributes:  g: Graphs.SimpleDiGraph Object  nodes: Vector of node names; node names are of type Any  edges: Vector of edges; edges are tuples of integers  node_map: dictionary pointing node name to node number  edge_map: dictionary pointing tuple (nodename1, nodename2) to (nodenumber1, nodenumber2)  node_data: NodeData object with attributes and data  edge_data: EdgeData object with attributes and data  graph_data: GraphData object with attributes and data\n\n\n\n\n\n","category":"type"},{"location":"api/#PlasmoData.DataDiGraph-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"API Manual","title":"PlasmoData.DataDiGraph","text":"DataDiGraph(adjacency_matrix::AbstractMatrix)\n\nConstructor for building a DataDiGraph object from an adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.DataDiGraph-Union{Tuple{}, Tuple{M2}, Tuple{M1}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T}} where {T<:Integer, T1, T2, T3, M1<:Matrix{T1}, M2<:Matrix{T2}}","page":"API Manual","title":"PlasmoData.DataDiGraph","text":"DataDiGraph{T, T1, T2, M1, M2}()\nDataDiGraph()\n\nConstructor for initializing and empty DataDiGraph object. Datatypes are as follows: T is the integer type for indexing, T1 and T2 are the data type in the node and edge data respectively, and M1 <: AbstractMatrix{T1} corresponds to the node data and M2 <: AbstractMatrix{T2} corresponds to the edge data.\n\nWhen T, T1, T2, M1, and M2 are not defined, the defaults are Int, Float64, Float64, Matrix{Float64}, and Matrix{Float64} respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.DataGraph","page":"API Manual","title":"PlasmoData.DataGraph","text":"DataGraph{T, T1, T2, T3, M1, M2}\n\nObject for building and storing undirected graphs that contain numerical data on nodes and/or edges.\n\nDataGraphs have the following attributes:  g: Graphs.SimpleGraph Object  nodes: Vector of node names; node names are of type Any  edges: Vector of edges; edges are tuples of integers  node_map: dictionary pointing node name to node number  edge_map: dictionary pointing tuple (nodename1, nodename2) to (nodenumber1, nodenumber2)  node_data: NodeData object with attributes and data  edge_data: EdgeData object with attributes and data  graph_data: GraphData object with attributes and data\n\n\n\n\n\n","category":"type"},{"location":"api/#PlasmoData.DataGraph-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"API Manual","title":"PlasmoData.DataGraph","text":"DataGraph(adjacency_matrix::AbstractMatrix)\n\nConstructor for building a DataGraph object from an adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.DataGraph-Union{Tuple{Array{Tuple{N1, N2}, 1}}, Tuple{N2}, Tuple{N1}} where {N1, N2}","page":"API Manual","title":"PlasmoData.DataGraph","text":"DataGraph(edge_list)\n\nConstructor for building a DataGraph object from a list of edges, where the edge list is a vector of Tuple{Any, Any}.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.DataGraph-Union{Tuple{M2}, Tuple{M1}, Tuple{T}, Tuple{Vector{Any}, Array{Tuple{T, T}, 1}}} where {T<:Int64, M1<:(Matrix), M2<:(Matrix)}","page":"API Manual","title":"PlasmoData.DataGraph","text":"DataGraph(nodes, edges; kwargs)\n\nConstructor for building a DataGraph object from a list of nodes and edges. Key word arguments include ne, fadjlist, node_attributes, edge_attributes, node_map, edge_map, node_data, and edge_data.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.DataGraph-Union{Tuple{}, Tuple{M2}, Tuple{M1}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T}} where {T<:Integer, T1, T2, T3, M1<:AbstractMatrix{T1}, M2<:AbstractMatrix{T2}}","page":"API Manual","title":"PlasmoData.DataGraph","text":"DataGraph{T, T1, T2, T3, M1, M2}()\nDataGraph()\n\nConstructor for initializing and empty DataGraph object. Datatypes are as follows: T is the integer type for indexing, T1, T2, and T3 are the data type in the node, edge, and graph data respectively, and M1 <: AbstractMatrix{T1} corresponds to the node data and M2 <: AbstractMatrix{T2} corresponds to the edge data.\n\nWhen T, T1, T2, T3, M1, and M2 are not defined, the defaults are Int, Float64, Float64, Float64, Matrix{Float64}, and Matrix{Float64} respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.EdgeData","page":"API Manual","title":"PlasmoData.EdgeData","text":"EdgeData{T, T2, M2}\n\nObject for building and storing data corresponding to the edges of a graph. Data is stored in a matrix, but columns of the matrix have attribute names stored in this struct\n\nEdgeData have the following attributes:  attributes: vector of strings with length equal to the number of columns of data. Each  entry is the name of the attribute of that column of data  attribute_map: dictionary with keys matching the entries of attributes. Maps the key  to the corresponding column index  data: Matrix with the number of rows corresponding to the number of edgess in the graph  and with a column for each attribute in attributes\n\n\n\n\n\n","category":"type"},{"location":"api/#PlasmoData.EdgeData-Union{Tuple{}, Tuple{Vector{String}}, Tuple{M2}, Tuple{T}, Tuple{Vector{String}, Dict{String, T}}, Tuple{Vector{String}, Dict{String, T}, M2}} where {T<:Real, M2<:(AbstractMatrix)}","page":"API Manual","title":"PlasmoData.EdgeData","text":"EdgeData(attributes = Vector{String}(),\n    attribute_map = Dict{String, Int}(),\n    data = Array{Float64}(undef, (0, 0))\n)\n\nConstructor for building EdgeData{T, T2, M2}\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.GraphData","page":"API Manual","title":"PlasmoData.GraphData","text":"GraphData{T, T2, M2}\n\nObject for building and storing data corresponding to a graph. Data is stored in a vector, but entries of the vector have attribute names stored in this struct\n\nGraphData have the following attributes:  attributes: vector of strings with length equal to the length of data. Each  entry is the name of the attribute of that column of data  attribute_map: dictionary with keys matching the entries of attributes. Maps the key  to the corresponding vector index  data: Vector with length equal to the number of attributes\n\n\n\n\n\n","category":"type"},{"location":"api/#PlasmoData.GraphData-Union{Tuple{}, Tuple{Vector{String}}, Tuple{T3}, Tuple{T}, Tuple{Vector{String}, Dict{String, T}}, Tuple{Vector{String}, Dict{String, T}, Vector{T3}}} where {T<:Real, T3}","page":"API Manual","title":"PlasmoData.GraphData","text":"GraphData(attributes = Vector{String}(),\n    attribute_map = Dict{String, Int}(),\n    data = Vector{Float64}(undef, 0)\n)\n\nConstructor for building GraphData{T, T3}\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.NodeData","page":"API Manual","title":"PlasmoData.NodeData","text":"NodeData{T, T1, M1}\n\nObject for building and storing data corresponding to the nodes of a graph. Data is stored in a matrix, but columns of the matrix have attribute names stored in this struct\n\nNodeData have the following attributes:  attributes: vector of strings with length equal to the number of columns of data. Each  entry is the name of the attribute of that column of data  attribute_map: dictionary with keys matching the entries of attributes. Maps the key  to the corresponding column index  data: Matrix with the number of rows corresponding to the number of nodes in the graph  and with a column for each attribute in attributes\n\n\n\n\n\n","category":"type"},{"location":"api/#PlasmoData.NodeData-Union{Tuple{}, Tuple{Vector{String}}, Tuple{M1}, Tuple{T}, Tuple{Vector{String}, Dict{String, T}}, Tuple{Vector{String}, Dict{String, T}, M1}} where {T<:Real, M1<:(AbstractMatrix)}","page":"API Manual","title":"PlasmoData.NodeData","text":"NodeData(attributes = Vector{String}(),\n    attribute_map = Dict{String, Int}(),\n    data = Array{Float64}(undef, (0, 0))\n)\n\nConstructor for building NodeData{T, T1, M1}\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData._build_matrix_graph!-NTuple{8, Any}","page":"API Manual","title":"PlasmoData._build_matrix_graph!","text":"_build_matrix_graph!\n\nConstructs the graph structure for the function matrix_to_graph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData._get_bfs_dfs_list-Union{Tuple{N}, Tuple{DataDiGraph, N, String, Symbol}} where N","page":"API Manual","title":"PlasmoData._get_bfs_dfs_list","text":"_get_bfs_dfs_list(dg::DataDiGraph, node, algorithm, dir)\n\nReturns the list of nodes that are upstream or downstream of node in the DataDiGraph dg\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge!-Union{Tuple{N2}, Tuple{N1}, Tuple{DataDiGraph, N1, N2}} where {N1, N2}","page":"API Manual","title":"PlasmoData.add_edge!","text":"add_edge!(dg, node_1, node_2)\nadd_edge!(dg, (node1, node2))\n\nAdd an edge to the DataDiGraph, dg. If the nodes are not defined in the graph, they are added to the graph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge!-Union{Tuple{N2}, Tuple{N1}, Tuple{DataGraph, N1, N2}} where {N1, N2}","page":"API Manual","title":"PlasmoData.add_edge!","text":"add_edge!(dg, node_1, node_2)\nadd_edge!(dg, (node1, node2))\n\nAdd an edge to the DataGraph, dg. If the nodes are not defined in the graph, they are added to the graph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge_attribute!-Union{Tuple{D}, Tuple{D, String}, Tuple{D, String, Any}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.add_edge_attribute!","text":"add_edge_attribute!(datagraph, attribute, default_weight = 0.0)\nadd_edge_attribute!(datadigraph, attribute, default_weight = 0.0)\n\nAdd a column filled with default_weight to the edge_data matrix with the name attribute. If attribute already exists in the edge data, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge_data!-Union{Tuple{N4}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{DataDiGraph, N1, N2, N3}, Tuple{DataDiGraph, N1, N2, N3, String}} where {N1, N2, N3, N4}","page":"API Manual","title":"PlasmoData.add_edge_data!","text":"add_edge_data!(datadigraph, node_name1, node_name2, edge_weight, attribute_name)\nadd_edge_data!(datadigraph, edge, edge_weight, attribute_name)\n\nAdd a weight value for the edge between nodename1 and nodename2 in the DataDiGraph object. When using the second function, edge must be a tuple with two node names. User must pass an \"attribute name\" for the given weight. All other edges that do not have an edge_weight value defined for that attribute name default to a value of zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge_data!-Union{Tuple{N4}, Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{DataGraph, N1, N2, N3, String}} where {N1, N2, N3, N4}","page":"API Manual","title":"PlasmoData.add_edge_data!","text":"add_edge_data!(datagraph, node_name1, node_name2, edge_weight, attribute_name)\nadd_edge_data!(datagraph, edge, edge_weight, attribute_name)\n\nAdd a weight value for the edge between nodename1 and nodename2 in the DataGraph object. When using the second function, edge must be a tuple with two node names. User must pass an \"attribute name\" for the given weight. All other edges that do not have an edge_weight value defined for that attribute name default to a value of zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge_dataset!-Union{Tuple{N}, Tuple{DataGraph, Dict, String}} where N","page":"API Manual","title":"PlasmoData.add_edge_dataset!","text":"add_edge_dataset!(dg::D, weight_dict, attribute) where {D <: DataGraphUnion}\n\nAdd the data in weight_dict as edge data on dg under the name attribute. weight_dict must contain keys that correspond to the edges (as node names, not integers) in dg.edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge_dataset!-Union{Tuple{N}, Tuple{DataGraph, Vector, String}} where N","page":"API Manual","title":"PlasmoData.add_edge_dataset!","text":"add_edge_dataset!(dg::D, weight_list, attribute) where {D <: DataGraphUnion}\n\nAdd the entries of weight_list as edge data on dg under the name attribute. weight_list must be the same length as the number of edges in dg. Entries of weight_list will be added as edge data in the order that edges are listed in dg.edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_edge_dataset!-Union{Tuple{N}, Tuple{DataGraph, Vector, Vector, String}} where N","page":"API Manual","title":"PlasmoData.add_edge_dataset!","text":"add_edge_dataset!(dg::D, edge_list, weight_list, attribute) where {D <: DataGraphUnion}\n\nAdd the edge data in weight_list to dg. edge_list is a list of edges (as node names, not integers) in dg and weight_list is a list of data/objects to be saved as edge data under the name attribute. edge_list and weight_list must have the same length, and entries of weight_list will be added to the corresponding edge in edge_list\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_graph_data!-Union{Tuple{D}, Tuple{D, Any, String}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.add_graph_data!","text":"add_graph_data!(dg::D, weight, attribute) where {D <: DataGraphUnion}\n\nAdd the value weight to the graph under the name attribute. If the attribute is already defined, the value will be reset to weight.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_node!-Union{Tuple{N}, Tuple{DataDiGraph, N}} where N","page":"API Manual","title":"PlasmoData.add_node!","text":"add_node!(dg, node_name)\n\nAdd the node node_name to the DataDiGraph dg\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_node!-Union{Tuple{N}, Tuple{DataGraph, N}} where N","page":"API Manual","title":"PlasmoData.add_node!","text":"add_node!(dg, node_name)\n\nAdd the node node_name to the DataGraph dg\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_node_attribute!-Union{Tuple{D}, Tuple{D, String}, Tuple{D, String, Any}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.add_node_attribute!","text":"add_node_attribute!(datagraph, attribute, default_weight = 0.0)\nadd_node_attribute!(datadigraph, attribute, default_weight = 0.0)\n\nAdd a column filled with default_weight to the node_data matrix with the name attribute. If attribute already exists in the node data, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_node_data!-Union{Tuple{N3}, Tuple{N2}, Tuple{N1}, Tuple{D}, Tuple{D, N1, N2}, Tuple{D, N1, N2, String}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), N1, N2, N3}","page":"API Manual","title":"PlasmoData.add_node_data!","text":"add_node_data!(dg::D, node_name, node_weight, attribute_name) where {D <: DataGraphUnion}\n\nAdd a weight value for the given node name in the DataGraph object. User must pass an \"attribute name\" for the given weight. All other nodes that do not have a node_weight value defined for that attribute name default to a value of zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_node_dataset!-Union{Tuple{N}, Tuple{D}, Tuple{D, Dict, String}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), N}","page":"API Manual","title":"PlasmoData.add_node_dataset!","text":"add_node_dataset!(dg::D, weight_dict, attribute) where {D <: DataGraphUnion}\n\nAdd the data in weight_dict as node data on dg under the name attribute. weight_dict must contain keys that correspond to the node names in dg.nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_node_dataset!-Union{Tuple{N}, Tuple{D}, Tuple{D, Vector, String}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), N}","page":"API Manual","title":"PlasmoData.add_node_dataset!","text":"add_node_dataset!(dg::D, weight_list, attribute) where {D <: DataGraphUnion}\n\nAdd the entries of weight_list as node data on dg under the name attribute. weight_list must be the same length as the number of nodes in dg. Entries of weight_list will be added as node data in the order that nodes are listed in dg.nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.add_node_dataset!-Union{Tuple{N}, Tuple{D}, Tuple{D, Vector, Vector, String}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), N}","page":"API Manual","title":"PlasmoData.add_node_dataset!","text":"add_node_dataset!(dg::D, node_list, weight_list, attribute) where {D <: DataGraphUnion}\n\nAdd the node data in weight_list to dg. node_list is a list of nodes in dg and weight_list is a list of values/things to be saved as node data under the name attribute. node_list and weight_list must have the same length, and entries of weight_list will be added to the corresponding node in node_list\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.adjacency_matrix-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.adjacency_matrix","text":"adjacency_matrix(datagraph)\nadjacency_matrix(datadigraph)\n\nReturn the adjacency matrix of a DataGraph object\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.aggregate-Union{Tuple{N}, Tuple{DataDiGraph, Vector, N}} where N","page":"API Manual","title":"PlasmoData.aggregate","text":"aggregate(datadigraph, node_list, aggregated_node_name; node_fn = mean, edge_fn = mean)\n\nAggregates all the nodes in node_list into a single node which is called aggregated_node_name. If nodes have any weight/attribute values defined, these values are combined via the node_fn function. The default for node_fn is Statistics.mean which averages the data for the nodes in node_list. Edge data are also are also combined via the edge_fn when two or more nodes in the node_list are connected to the same node and these edges have data defined on them. The edge_fn also defaults to Statistics.mean\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.aggregate-Union{Tuple{N}, Tuple{DataGraph, Vector, N}} where N","page":"API Manual","title":"PlasmoData.aggregate","text":"aggregate(datagraph, node_list, aggregated_node_name; node_fn = mean, edge_fn = mean)\n\nAggregates all the nodes in node_list into a single node which is called aggregated_node_name. If nodes have any weight/attribute values defined, these values are combined via the node_fn function. The default for node_fn is Statistics.mean which averages the data for the nodes in node_list. Edge data are also are also combined via the edge_fn when two or more nodes in the node_list are connected to the same node and these edges have data defined on them. The edge_fn also defaults to Statistics.mean\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.average_degree-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.average_degree","text":"average_degree(datagraph)\n\nReturns the average degree for datagraph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.downstream_nodes-Union{Tuple{N}, Tuple{DataDiGraph, N}} where N","page":"API Manual","title":"PlasmoData.downstream_nodes","text":"downstream_nodes(dg::DataDiGraph, node; algorithm = \"bfs\")\n\nReturn a list of all the nodes that are downstream of node in the DataDiGraph dg. Algorithm options are \"bfs\" and \"dfs\"\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.filter_edges-Union{Tuple{R}, Tuple{DataDiGraph, R}, Tuple{DataDiGraph, R, String}} where R<:Real","page":"API Manual","title":"PlasmoData.filter_edges","text":"filter_edges(datadigraph, filter_value, attribute = dg.edge-data.attributes[1]; fn = isless)\n\nRemoves the edges of the graph whose weight value of attribute is greater than the given filter_value. If attribute is not specified, this defaults to the first attribute within the DataGraph's EdgeData.\n\nfn is a function that takes an input of two scalar values and is broadcast to the data vector. For example, isless, isgreater, isequal\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.filter_edges-Union{Tuple{R}, Tuple{DataGraph, R}, Tuple{DataGraph, R, String}} where R<:Real","page":"API Manual","title":"PlasmoData.filter_edges","text":"filter_edges(datagraph, filter_value, attribute = dg.edge_data.attributes[1]; fn = isless)\n\nRemoves the edges of the graph whose weight value of attribute is greater than the given filter_value. If attribute is not specified, this defaults to the first attribute within the DataGraph's EdgeData.\n\nfn is a function that takes an input of two scalar values and is broadcast to the data vector. For example, isless, isgreater, isequal\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.filter_nodes-Union{Tuple{R}, Tuple{DataDiGraph, R}, Tuple{DataDiGraph, R, String}} where R<:Real","page":"API Manual","title":"PlasmoData.filter_nodes","text":"filter_nodes(datadigraph, filter_value, attribute = dg.node_data.attributes[1]; fn = isless)\n\nRemoves the nodes of the graph whose weight value of attribute is greater than the given filter_value. If attribute is not specified, this defaults to the first attribute within the DataGraph's NodeData.\n\nfn is a function that takes an input of two scalar values and is broadcast to the data vector. For example, isless, isgreater, isequal\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.filter_nodes-Union{Tuple{R}, Tuple{DataGraph, R}, Tuple{DataGraph, R, String}} where R<:Real","page":"API Manual","title":"PlasmoData.filter_nodes","text":"filter_nodes(datagraph, filter_value, attribute = dg.node_data.attributes[1]; fn = isless)\n\nRemoves the nodes of the graph whose weight value of attribute is greater than the given filter_value. If attribute is not specified, this defaults to the first attribute within the DataGraph's NodeData.\n\nfn is a function that takes an input of two scalar values and is broadcast to the data vector. For example, isless, isgreater, isequal\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_EC-Tuple{DataGraph}","page":"API Manual","title":"PlasmoData.get_EC","text":"get_EC(datagraph)\n\nReturns the Euler Characteristic for a DataGraph. The Euler Characteristic is equal to the number of nodes minus the number of edges or the number of connected components minus the number of cycles\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_edge_attributes-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_edge_attributes","text":"get_edge_attributes(dg::D) where {D <: DataGraphUnion}\n\nReturns the list of attributes contained in the EdgeData of dg\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_edge_data-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_edge_data","text":"get_edge_data(dg::D) where {D <: DataGraphUnion}\n\nReturns the data object from a DataGraph's or DataDiGraph's EdgeData\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_edge_data-Union{Tuple{D}, Tuple{D, String}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_edge_data","text":"get_edge_data(dg::D, attribute) where {D <: DataGraphUnion}\n\nReturns a vector of the edge data corresponding to the attribute\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_edge_data-Union{Tuple{D}, Tuple{D, Vector{String}}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_edge_data","text":"get_edge_data(dg::D, attribute_list; edges) where {D <: DataGraphUnion}\n\nReturns a matrix of the edge data for the attributes in attribute list in the order that the attributes are defined in the list\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_edge_data-Union{Tuple{N2}, Tuple{N1}, Tuple{DataDiGraph, N1, N2, String}} where {N1, N2}","page":"API Manual","title":"PlasmoData.get_edge_data","text":"get_edge_data(datagraph, node_name1, node_name2, attribute_name)\nget_edge_data(datagraph, edge, attribute_name)\n\nReturns the value of attribute name on the edge between node_name1 and node_name2. edge is a tuple containing node_name1 and node_name2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_edge_data-Union{Tuple{N2}, Tuple{N1}, Tuple{DataGraph, N1, N2, String}} where {N1, N2}","page":"API Manual","title":"PlasmoData.get_edge_data","text":"get_edge_data(datagraph, node_name1, node_name2, attribute_name)\nget_edge_data(datagraph, edge, attribute_name)\n\nReturns the value of attribute name on the edge between node_name1 and node_name2. edge is a tuple containing node_name1 and node_name2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_graph_attributes-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_graph_attributes","text":"get_graph_attributes(dg::D) where {D <: DataGraphUnion}\n\nReturns the list of attributes contained in the GraphData of dg\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_graph_data-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_graph_data","text":"get_graph_data(dg::D) where {D <: DataGraphUnion}\n\nReturns the data object from a DataGraph's or DataDiGraph's GraphData\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_node_attributes-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_node_attributes","text":"get_node_attributes(dg::D) where {D <: DataGraphUnion}\n\nReturns the list of attributes contained in the NodeData of dg\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_node_data-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_node_data","text":"get_node_data(dg::D) where {D <: DataGraphUnion}\n\nReturns the data object from a DataGraph's or DataDiGraph's NodeData\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_node_data-Union{Tuple{D}, Tuple{D, String}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_node_data","text":"get_node_data(dg::D, attribute::String) where {D <: DataGraphUnion}\n\nReturns a vector of the edge data for the attribute\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_node_data-Union{Tuple{D}, Tuple{D, Vector{String}}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_node_data","text":"get_node_data(dg::D, attribute_list; nodes = dg.nodes) where {D <: DataGraphUnion}\n\nReturns a matrix of the node data for the attributes in attribute list in the order that the attributes are defined in the list. If nodes is defined, returns the subset of data corresponding to nodes in the order that they are defined in nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_node_data-Union{Tuple{N}, Tuple{DataDiGraph, N, String}} where N","page":"API Manual","title":"PlasmoData.get_node_data","text":"get_node_data(datagraph, node_name, attribute_name)\n\nReturns the value of attribute name on the given node\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_node_data-Union{Tuple{N}, Tuple{DataGraph, N, String}} where N","page":"API Manual","title":"PlasmoData.get_node_data","text":"get_node_data(datagraph, node_name, attribute_name)\n\nReturns the value of attribute name on the given node\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_ordered_edge_data-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_ordered_edge_data","text":"get_ordered_edge_data(dg::D) where {D <: DataGraphUnion}\n\nReturns the ordered edge data matrix. For DataGraphs, this means all edges connected to dg.nodes[1] are ordered first, and so on. For DataDiGraphs, this means that all edges originating at dg.nodes[1] are ordered first, and so on for length(dg.nodes)\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_ordered_edge_data-Union{Tuple{D}, Tuple{D, String}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_ordered_edge_data","text":"get_ordered_edge_data(dg::D, attribute::String) where {D <: DataGraphUnion}\n\nReturns the ordered edge data vector for attribute. For DataGraphs, this means all edges connected to dg.nodes[1] are ordered first, and so on. For DataDiGraphs, this means that all edges originating at dg.nodes[1]  are ordered first, and so on for length(dg.nodes)\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_ordered_edge_data-Union{Tuple{D}, Tuple{D, Vector{String}}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.get_ordered_edge_data","text":"get_ordered_edge_data(dg::D, attribute_list) where {D <: DataGraphUnion}\n\nReturns the ordered edge data matrix for the attributes in attribute_list. For DataGraphs, this means all edges connected to dg.nodes[1] are ordered first, and so on. For DataDiGraphs, this means that all edges originating at dg.nodes[1]  are ordered first, and so on for length(dg.nodes)\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_path-Union{Tuple{T2}, Tuple{T1}, Tuple{D}, Tuple{D, T1, T2}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), T1, T2}","page":"API Manual","title":"PlasmoData.get_path","text":"get_path(datagraph, src_node, dst_node; algorithm = \"Dijkstra\")\n\nReturns the shortest path in the datagraph between src_node and dst_node. Shortest path is computed by Dijkstra's algorithm\n\nalgorithm is a string key word. Options are limited to \"Dijkstra\", \"BellmanFord\"\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.get_path-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{D}, Tuple{D, T1, T2, T3}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), T1, T2, T3}","page":"API Manual","title":"PlasmoData.get_path","text":"get_path(datagraph, src_node, intermediate_node, dst_node; algorithm = \"Dijkstra\")\n\nReturns the shortest path in the datagraph between src_node and dst_node which passes through intermediate node.\n\nalgorithm is a string key word. Options are limited to \"Dijkstra\", \"BellmanFord\"\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.has_edge-Union{Tuple{N2}, Tuple{N1}, Tuple{DataDiGraph, N1, N2}} where {N1, N2}","page":"API Manual","title":"PlasmoData.has_edge","text":"has_edge(datagraph, node1, node2)\n\nReturn true if there is an edge going from node1 to node2 in datadigraph. Else return false\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.has_edge-Union{Tuple{N2}, Tuple{N1}, Tuple{DataGraph, N1, N2}} where {N1, N2}","page":"API Manual","title":"PlasmoData.has_edge","text":"has_edge(datagraph, node1, node2)\n\nReturn true if there is an edge between node1 and node2 in datagraph. Else return false\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.has_node-Union{Tuple{T}, Tuple{D}, Tuple{D, T}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), T}","page":"API Manual","title":"PlasmoData.has_node","text":"has_node(datagraph, node)\nhas_node(datadigraph, node)\n\nreturns true if node is in the graph. Else return false\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.has_path-Union{Tuple{T2}, Tuple{T1}, Tuple{D}, Tuple{D, T1, T2}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), T1, T2}","page":"API Manual","title":"PlasmoData.has_path","text":"has_path(datagraph, src_node, dst_node)\n\nReturns true if a path exists in the datagraph between src_node to dst_node. Else returns false\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.has_path-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{D}, Tuple{D, T1, T2, T3}} where {D<:(Union{DataDiGraph{T}, DataGraph{T}} where T), T1, T2, T3}","page":"API Manual","title":"PlasmoData.has_path","text":"has_path(datagraph, src_node, intermediate_node, dst_node)\n\nReturns true if a path exists in the datagraph between src_node and dst_node which passes through the intermediate node. Else returns false\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.index_to_nodes-Union{Tuple{D}, Tuple{D, Vector}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.index_to_nodes","text":"index_to_nodes(datagraph, index_list)\n\nFrom a list of integer indeices, return a list of corresponding nodes in the datagraph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.matrix_to_graph-Union{Tuple{AbstractMatrix{T1}}, Tuple{T1}} where T1","page":"API Manual","title":"PlasmoData.matrix_to_graph","text":"matrix_to_graph(matrix; diagonal = true, attribute=\"weight\")\nmatrix_to_graph(array_3d; diagonal = true, attributes = [\"weight$i\" for i in 1:size(array_3d)[3]])\n\nConstructs a DataGraph object from a matrix and saves the matrix data as node attributes under the name attribute. If diagonal = false, the graph has a mesh structure, where each matrix entry is represented by a node, and each node is connected to the adjacent matrix entries/nodes. If diagonal = true, entries of the matrix are also connected to the nodes diagonal to them (i.e., entry (i,j) is connected to (i-1, j-1), (i + 1, j -1), etc.).\n\nIf a 3D matrix is passed to the function, it treats the first two dimensions as the matrix and then saves the data in the third dimension as different weights (i.e., for array of size dim1, dim2, and dim3, entry (i,j) has dim3 weights). attribute_list can be defined by the user to give names to each weight in the third dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.mvts_to_graph-Union{Tuple{Any}, Tuple{R}, Tuple{Any, String}, Tuple{Any, String, R}} where R<:Real","page":"API Manual","title":"PlasmoData.mvts_to_graph","text":"mvts_to_graph(mvts, attribute)\n\nConverts a multivariate time series to a graph based on the covariance matrix. This first calculates the covariance of the multivariate time series (mvts) and then computes the covariance. It then forms the precision matrix by taking the inverse of the covariance and uses the function symmetric_matrix_to_graph to form the edge-weighted graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.ne-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.ne","text":"ne(dg::D) where {D <: DataGraphUnion}\n\nReturns the number of edges in a DataGraph or DataDiGraph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.nn-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.nn","text":"nn(dg::D) where {D <: DataGraphUnion}\nnv(dg::D) where {D <: DataGraphUnion}\n\nReturns the number of nodes (vertices) in a DataGraph or DataDiGraph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.nodes_to_index-Union{Tuple{D}, Tuple{D, Vector}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.nodes_to_index","text":"nodes_to_index(datagraph, node_list)\n\nFrom a list of nodes in the datagraph, return a list of their corresponding integer indices\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.order_edges!-Tuple{D} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.order_edges!","text":"order_edges!(dg) where {D <: DataGraphUnion}\n\nArranges in place the edges of dg so that they follow the order of dg.nodes. For DataGraphs, this means all edges connected to dg.nodes[1] are ordered first, and so on. For DataDiGraphs, this means that all edges originating at dg.nodes[1] are ordered first, and so on for length(dg.nodes)\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.remove_edge!-Union{Tuple{N2}, Tuple{N1}, Tuple{DataDiGraph, N1, N2}} where {N1, N2}","page":"API Manual","title":"PlasmoData.remove_edge!","text":"remove_edge!(datadigraph, node1, node2)\nremove_edge!(datadigraph, edge_tuple)\n\nRemove the directed edge from node1 to node2 from the datadigraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.remove_edge!-Union{Tuple{N2}, Tuple{N1}, Tuple{DataGraph, N1, N2}} where {N1, N2}","page":"API Manual","title":"PlasmoData.remove_edge!","text":"remove_edge!(datagraph, node1, node2)\nremove_edge!(datagraph, edge_tuple)\n\nRemove the edge between node1 and node2 from the datagraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.remove_node!-Union{Tuple{N}, Tuple{DataDiGraph, N}} where N","page":"API Manual","title":"PlasmoData.remove_node!","text":"remove_node!(datadigraph, node_name)\n\nRemoves the node (and any node data) from datadigraph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.remove_node!-Union{Tuple{N}, Tuple{DataGraph, N}} where N","page":"API Manual","title":"PlasmoData.remove_node!","text":"remove_node!(datagraph, node_name)\n\nRemoves the node (and any node data) from datagraph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.rename_edge_attribute!-Union{Tuple{D}, Tuple{D, String, String}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.rename_edge_attribute!","text":"rename_edge_attribute!(dg::D, attribute, new_name) where {D <: DataGraphUnion}\n\nRename the edge data attribute as new_name. If attribute is not defined, returns an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.rename_graph_attribute!-Union{Tuple{D}, Tuple{D, String, String}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.rename_graph_attribute!","text":"rename_graph_attribute!(dg::D, attribute, new_name) where {D <: DataGraphUnion}\n\nRename the graph data attribute as new_name. If attribute is not defined, returns an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.rename_node_attribute!-Union{Tuple{D}, Tuple{D, String, String}} where D<:(Union{DataDiGraph{T}, DataGraph{T}} where T)","page":"API Manual","title":"PlasmoData.rename_node_attribute!","text":"rename_node_attribute!(dg::D, attribute, new_name) where {D <: DataGraphUnion}\n\nRename the node data attribute as new_name. If attribute is not defined, returns an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.run_EC_on_edges-Tuple{DataGraph, Any}","page":"API Manual","title":"PlasmoData.run_EC_on_edges","text":"run_EC_on_edges(dg, threshold_range; attribute = dg.edge_data.attributes[1], scale = false)\n\nReturns the Euler Characteristic Curve by filtering the edges of the graph at each value in threshold_range and computing the Euler Characteristic after each filtration. If attribute is not defined, it defaults to the first attribute in the DataGraph's EdgeData. scale is a Boolean that indicates whether to scale the Euler Characteristic by the total number of objects (nodes + edges) in the original graph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.run_EC_on_nodes-Tuple{DataGraph, Any}","page":"API Manual","title":"PlasmoData.run_EC_on_nodes","text":"run_EC_on_nodes(dg, threshold_range; attribute = dg.node_data.attributes[1], scale = false)\n\nReturns the Euler Characteristic Curve by filtering the nodes of the graph at each value in threshold_range and computing the Euler Characteristic after each filtration. If attribute is not defined, it defaults to the first attribute in the DataGraph's NodeData. scale is a Boolean that indicates whether to scale the Euler Characteristic by the total number of objects (nodes + edges) in the original graph\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.symmetric_matrix_to_graph-Union{Tuple{R}, Tuple{M}} where {M<:(AbstractMatrix), R<:Real}","page":"API Manual","title":"PlasmoData.symmetric_matrix_to_graph","text":"symmetric_matrix_to_graph(matrix; attribute=\"weight\", tol = 1e-9)\n\nConstructs a DataGraph object from a symmetric matrix and saves the values of the matrix to their corresponding edges. The resulting graph is fully connected (every node is connected to every node) and the number of nodes is equal to the dimension of the matrix. Matrix values are saved as edge weights under the name attribute. tol is the tolerance used when testing that the matrix is symmetric.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.tensor_to_graph-Union{Tuple{A}, Tuple{A, String}} where A<:AbstractArray","page":"API Manual","title":"PlasmoData.tensor_to_graph","text":"tensor_to_graph(tensor, attribute)\n\nConstructs a graph from a 3-D array (a tensor). Each entry of the tensor is represented by a node, and each node is connected to the adjacent nodes in each dimension. This function creates the graph structure and saves the values of the tensor to their corresponding nodes as weight values under the name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlasmoData.upstream_nodes-Union{Tuple{N}, Tuple{DataDiGraph, N}} where N","page":"API Manual","title":"PlasmoData.upstream_nodes","text":"upstream_nodes(dg::DataDiGraph, node; algorithm = \"bfs\")\n\nReturn a list of all the nodes that are upstream of node in the DataDiGraph dg. Algorithm options are \"bfs\" and \"dfs\"\n\n\n\n\n\n","category":"method"},{"location":"#PlasmoData","page":"Introduction","title":"PlasmoData","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoData.jl is a package for Julia designed for representing and modeling data as graphs and for building graph models that contain large amounts of data on the nodes or edges of the graph. This package also has an accompanying package DataGraphPlots.jl which can be used for plotting the graphs. ","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install this package, you can use ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/zavalab/PlasmoData.jl\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/zavalab/PlasmoData.jl","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoData.jl is designed to store data within the graph structure and to manipulate that graph based on the data. It extends the package Graphs.jl, which is a highly optimized and efficient package in Julia. PlasmoData.jl enables representing datasets (such as matrices, images, or tensors) as graphs and for performing some topological data analysis (TDA). Some of these concepts can be found in this paper.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoData.jl uses an object DataGraph (or DataDiGraph for directed graphs) to store information. These objects contain the following features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"g: SimpleGraph (or SimpleDiGraph for directed graphs) containing the graph structure.\nnodes: A vector of nodes, where the entries of the vector are node names. These names are of type Any so that the nodes can use a variety of naming conventions (strings, symbols, tuples, etc.)\nedges: A vector of tuples, where each tuple contains two entries, where each entry relates to a node. \nnode_map: A dictionary that maps the node names to their index in the nodes vector\nedge_map: A dictionary that maps the edges to their index in the edges vector.\nnode_data: An object of type NodeData that includes a matrix of data, where the first dimension of the matrix corresponds to the node, and the second dimension corresponds to attributes for the nodes. Any number of attributes is allowed, and NodeData also includes attribute names and a mapping of the attribute name to the column of the data matrix. \nedge_data: An object of type EdgeData that includes a matrix of data, where the first dimension fo the matrix corresponds to the edges, and the second dimension corresponds to attributes for the edges. Any number of attributes is allowed, and EdgeData also includes attribute names and a mapping of the attribute name to the column of the data matrix. \ngraph_data: An object of type GraphData that includes a vector of data whose dimension corresponds to the number of attributes for the graph. Any number of attributes is allowed, and GraphData also includes attribute names and a mapping of the attribute name to the entry in the vector. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoData.jl includes several functions for building graphs from specific data structures, including functions like matrix_to_graph, symmetric_matrix_to_graph, and tensor_graph which build specific graph structures an save data to those structures. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PlasmoData.jl also includes functions for manipulating graph structure and analyzing the resulting topology of those structures. Functions filter_nodes, filter_edges, or aggregate change the graph structure based on the arguments passed to the functions. There are also functions such as get_EC, run_EC_on_nodes, and run_EC_on_edges that get the Euler Characteristic or the Euler Characteristic Curve for a graph, and other functions such as cycle_basis, diameter, or average_degree (largely extensions of Graphs.jl) for finding other topological descriptors. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Support for DataDiGraphs is still underway. However, for DataGraph objects, all functions shown above have doc strings, which can be accessed through the REPL by first typing ? and then the function or object name. ","category":"page"},{"location":"#Bug-Reports-and-Support","page":"Introduction","title":"Bug Reports and Support","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is under development, and significant changes will continue to come. If you encounter any issues or bugs, please submit them through the Github issue tracker. ","category":"page"}]
}
